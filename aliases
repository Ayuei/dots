#!/bin/ksh
#
# http://github.com/mitchweaver/dots
#
# note: this is meant for ksh/mksh
#

alias a=alias

a {fc,w}=true 

_ps1_git() { git branch 2> /dev/null | \
    sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' ; }

cd() { [ $# -eq 0 ] &&
           builtin cd ${HOME} ||
           builtin cd "$1"
        export PS1="$(get_PS1)" ; }

case ${SHELL} in
    /bin/ksh|/bin/bash)
        [ $(id -u) -eq 0 ] &&
            get_PS1() { echo "\[\e[0;32m\][root]\[\e[1;36m\] \W\[\e[1;37m\] " ; } ||
            get_PS1() { echo "\[\e[1;35m\]m\[\e[0;32m\]i\[\e[0;33m\]t\[\e[0;34m\]c\[\e[1;31m\]h\[\e[1;36m\] \W$(_ps1_git)\[\e[1;37m\] " ; } ;;
    /bin/mksh)
        _x="$(print \\001)"
        get_PS1() { 
            case ${PWD} in
                ${HOME}) tmp_pwd='~' ;;
                *) tmp_pwd=`basename "${PWD}"`
            esac
            echo -n "$_x$(print \\r)$_x\e[1;35mm$_x\e[0;32mi$_x\e[0;33mt$_x\e[0;34mc$_x\e[1;31mh$_x\e[1;36m $tmp_pwd$_x$(_ps1_git)$_x\e[1;37m "
        } ;;
    *) get_PS1() { echo "\u \W " ; }
esac

export PS1="$(get_PS1)"

netstart() { [ $# -eq 0 ] &&
                 doas /etc/netstart "$@" ||
                 doas /etc/netstart "$@" ; }
a disks="sysctl hw.disknames"
a disklabel='disklabel -h'
a disknames='sysctl hw.disknames'
a sensors="sysctl hw.sensors"
pkg_del() { pkg_delete $@ ; pkg_delete -a ; }
pkg() { case "$1" in
            add) shift ; pkg_add "$@" ;;
            del) shift ; pkg_del "$@" ;;
            info) shift ; pkg_info "$@" ;;
            search) shift ; pkg_info -Q "$@" ;;
            update) shift ; pkg_add -Uui "$@" ;;
            check) shift ; pkg_check "$@" ;;
            *) echo "?"
        esac ; }
a killall="pkill -9"
a cp='cp -rv'
a rm='rm -P'

type exa > /dev/null 2>&1 &&
    a ls='exa -F' ||
    a ls='ls -F'

a {l,sls,sl}=ls
a ll='l -l'
a la='l -a'
a lla='l -al'
a lsf='l "${PWD}"/*'

a {c,cc,cll,clear,clar,clea}='printf "\033c"'
a {cls,csl,cl,lc}='c;l'
a {e,ech,eho}=echo

a file='file -b -i -L'
a date="date '+%a %b %d - %l:%M %p'"
a {dmesg,dmegs}='dmesg | tail -n 20'

ext() { echo "${1##*.}" ; }
filename() { echo "${1%.*}" ; }

pa(){ ps auwwx | head ; }
ph(){ ps auwwx | grep -i -e ${USER} | head ; }

a mv='mv -v'
a {mkdir,mkd,mkdr}='mkdir -p'
mkcd() { mkd "$1" && cd "$1" ; }
mvcd() { mv "$1" "$2" && cd "$2" ; }
cpcd() { cp "$1" "$2" && cd "$2" ; }

du() { command du -ahLd 1 2> /dev/null | \
           /usr/bin/sort -rh | /usr/bin/head -n 20 ; }

a df='df -h'
a man='man -a'
a cx='chmod +x'
a chown='chown -R'

reload() { . ${HOME}/etc/aes
           . ${HOME}/etc/profile
           xrdb load ${HOME}/etc/Xresources
           xmodmap ${HOME}/etc/Xmodmap
           xset m 0 0 ; } > /dev/null

a jjar='java -jar'
nasm() { [ -f "$1" ] && c &&
             command nasm -f elf32 -g -F dwarf "$1" &&
                ld -m elf_i386 "${1%.*}.o" -o "${1%.*}" &&
                    ./"${1%.*}" ; }

a nf='neofetch'
a {irc,irssi}="irssi -c freenode"
a discline='dash ${HOME}/usr/bin/discline ; x'
a {rtv,reddit}="rtv --enable-media ; c"
a compton="pkill -9 compton ; compton & c"

w3m() { [ $# -eq 0 ] &&
            command w3m -F https://ddg.gg/lite ||
            command w3m -F "$@" ; }

bar() { pkill -9 bar lemonbar > /dev/null 2>&1
        ${HOME}/bin/bar & c ; }

a {mk,mkae}="make -j$(sysctl -n hw.ncpu)"
a mkc='make clean'
a mkall="make clean ; make && doas make install"

gcc() { command gcc $@
        echo -n "${PWD}"/"$(basename $1 -- 2> /dev/null)" \
        > /tmp/shell/last_gcc ; }

!g() { path="$(cat /tmp/shell/last_gcc -- 2> /dev/null)"
       [ -n "$path" ] &&
           { echo "gcc $path" ; command gcc "$path" ; } ||
                echo "No recent gcc" ; }

g(){ grep "$@" ; }
pg() { pgrep "$@" ; }
dg() { command du -ahLd 1  | g "$@" ; }
f () { [ $# -gt 0 ] && find . -iname "*$1*" ; }
hg() { [ $# -gt 0 ] && cat ${HISTFILE} | \
    grep "$@" | head -n 20 ; }
sg() { sysctl | g "$@" ; }

a {x,xx,xxx,q,qq,qqq,:q,:Q,:wq,:w}=exit

a reboot='doas reboot'
a shutdown='doas shutdown -p now'

mkxz() { f="$(e $1 | sed 's/\///')" &&
             tar -cvpf "$f.tar" "$f" &&
                 xz "$f.tar" &&
                     [ -f "$f.tar.xz" ] &&
                         rm -rf "$f" && unset f ; }
mkgz() { f="$(e $1 | sed 's/\///')" &&
            tar -cvzpf "$f.tar.gz" "$f" &&
                [ -f "$f.tar.gz" ] &&
                    rm -rf "$f" && unset f ; }
mkbz2() { f="$(e $1 | sed 's/\///')" &&
              tar -cvjpf "$f.tar.bz" "$f" &&
                  [ -f "$f.tar.bz" ] &&
                      rm -rf "$f" && unset f ; }

a {v,vi,vim,nvim}=${EDITOR}
vim() { [ $# -eq 0 ] &&
            command ${EDITOR} -c VimwikiIndex ||
                command ${EDITOR} -p "$@"
        [ -f "$1" ] && file="$1" || \
            { [ -f "${PWD}/$1" ] && \
              file="${PWD}/$1" ; } ||
                  file="${PWD}/$(basename $1)"
        echo -n "$file" > /tmp/last_vi ; }

!v() { path="$(cat /tmp/last_vi -- 2> /dev/null)"
       [ -n "$path" ] &&
           { echo "v $path" ; v "$path" ; x ; } ||
               echo "No recent vi" ; }

a {notepad,vtmp}='${EDITOR} /tmp/notepad.md'
a {suvim,suvi}='doas ${EDITOR}'
a view='${EDITOR} -R'

a {h,htpo,hto,ht,hpot,hotp}=htop
a hm='h -u ${USER}'
a hr='h -u root'

ranger() {
    [ $# -eq 0 ] &&
        { [ "${PWD}" = ${HOME} ] &&
          path=${HOME} || path="${PWD}" ; } ||
              path="$1"
    echo -n "$path" > /tmp/last_ranger
    command ranger "$@"
}
!r() { path="$(cat /tmp/last_ranger -- 2> /dev/null)"
    [ -n "$path" ] &&
        { echo "ranger $path" ; ranger "$path" ; x ; } ||
            echo "No recent ranger" ; }

# This is a hack to let you use "$@" with an 1-char alias
# in shells like ksh. You can't do this without a function,
# but you also can't have a 1-char long function.
_r() { ranger "$@" ; x ; }
a r='_r';[ -n "$RANGER_LEVEL" ] && \
    PS1="$PS1"'(RANGER): ' && clear && ls -F

trans(){ command trans -no-auto -b "$@" ; }
rtrans(){ command trans -from en -to de -no-auto -b "$@" ; }

a yt="c; youtube-viewer -C -q --vd=high"
a ytm="c;yt -n"
a ytdv="c;yt -d"
a ytdm='c;yt -n -d --convert-to=opus \
    --convert-cmd="ffmpeg -loglevel -8 -i \
    file:*IN* -vn -acodec libopus -ab 128k -y *OUT*"'
a ytsubs='c;yt --subs-videos --subs-order=unread'
a ytchans='c;yt --subscriptions'
a ytfavs='c;yt --favorites=mine'
a ytme='c;yt --channel-videos=mine'

mpv() { [ $# -gt 0 ] &&
        { [ $(pgrep mpv) ] && killall mpv ; } ||
        command mpv --title=mpv "$@" & x ; }
mpvm() { mpv --no-video "$@" ; }
mpvx() { (mpv "$(xsel -o)" &) ; }
mpvyt() { mpv ytdl://ytsearch:"$@" ; }
mpvytm() { mpv --no-video ytdl://ytsearch:"$@" ; }

a ytdl='youtube-dl --geo-bypass --prefer-ffmpeg'
a ytdlm="youtube-dl --extract-audio --geo-bypass \
    --prefer-ffmpeg  --audio-quality 0 --audio-format opus"

a record-webcam='ffmpeg -i /dev/video0 -f sndio -i \
    default "$(date)".mp4'

a feh='feh -q -N -x --scale-down'
a resize-half='mogrify -resize 50%X50%'
a resize-quarter='mogrify -resize 25%X25%'
import() { command import -quiet -silent -window root \
       -quality 100 ${HOME}/import.png ; }

a w='curl http://wttr.in/Schmalkalden'
a wsd='curl http://wttr.in/Dakota_State_University'
a wok='curl http://wttr.in/Claremore'

a {xs,xc}='xsel -o ; e'

a rsync='rsync -rtvulh4 --progress --delete' #-c
a scp='scp -rp4'
p() { [ $# -eq 0 ] &&
          addr=mitchweaver.xyz ||
              addr="$1"
      ping -c 1 -n -q -s 1 -w 10 \
          "$addr" > /dev/null 2>&1 &&
              echo "UP" || echo "DOWN" ; }
a pubip='curl https://wtfismyip.com/text'

a sshd='doas /usr/sbin/sshd'

a kshrc='v ${HOME}/etc/kshrc'
a {aliases,alaises,aliase}='v ${HOME}/etc/aliases'
a profile='v ${HOME}/etc/profile'
a {vimrc,virmc}='v ${HOME}/etc/vimrc'
a {bmk,bmks}='v ${HOME}/var/files/surf-bookmarks.txt'
a vssh='v ${HOME}/.ssh/config'
a xinitrc='v ${HOME}/etc/xinitrc'

gup() { git add -A &&
        git commit -m "$@" &&
        git push -u origin $(git branch 2> /dev/null | \
            sed -e '/^[^*]/d' | sed 's/* //') ; }
gadd() { [ $# -eq 0 ] && git add -A || git add "$@" ; }
gmit() { { [ $# -eq 1 ] && git add -A && \
                git commit -m "$@" ; } ||
                    { git add "$1" ; shift
            git commit -m "$@" ; } ; }
gout() { git push -u origin $(git rev-parse \
    --abbrev-ref HEAD) "$@" ; }
gdiff() { git diff origin/master ; }
gstat(){ git status ; }
greset() { git reset --hard HEAD~"$1" ; }
gbase() { [ $# -eq 0 ] &&
                git rebase -i HEAD~10 ||
                git rebase -i HEAD~"$1" ; }
gmote() { git init ; git remote add origin "$1" ; }
gclone() { git clone https://github.com/"$1" ; }
a gbort='git rebase --abort'
a glog='git log'
a gfetch='git fetch'
a gppull='git pull'
a gbranch='git branch'
a {gcheck,checkout}='git checkout'

a {..,cd..}='cd ..'
a ...='cd ../..'
a ....='cd ../../..'

g~() { cd ${HOME} ; cls ; }
m~() { mv "$1" ${HOME} ; }
Y~() { cp "$1" ${HOME} ; }
gh() { cd ${HOME}/var/files/homework ; cls ; }
mh() { mv "$1" ${HOME}/var/files/homework ; }
Yh() { cp "$1" ${HOME}/var/files/homework ; }
gw() { cd ${HOME}/var/workspace ; cls ; }
mw() { mv "$1" ${HOME}/var/workspace ; }
Yw() { cp "$1" ${HOME}/var/workspace ; }
gT() { cd /tmp ; cls ; }
mT() { mv "$1" /tmp ; }
YT() { cp "$1" /tmp ; }
gb() { cd ${HOME}/bin ; cls ; }
mb() { mv "$1" ${HOME}/bin ; }
Yb() { cp "$1" ${HOME}/bin ; }
gf() { cd ${HOME}/var/files ; cls ; }
mf() { mv "$1" ${HOME}/var/files ; }
Yf() { cp "$1" ${HOME}/var/files ; }
gd() { cd ${HOME}/var/downloads ; cls ; }
md() { mv "$1" ${HOME}/var/downloads ; }
Yd() { cp "$1" ${HOME}/var/downloads ; }
gi() { cd ${HOME}/var/images ; cls ; }
mi() { mv "$1" ${HOME}/var/images ; }
Yi() { cp "$1" ${HOME}/var/images ; }
gW() { cd ${HOME}/var/images/wallpapers ; cls ; }
mW() { mv "$1" ${HOME}/var/images/wallpapers ; }
YW() { cp "$1" ${HOME}/var/images/wallpapers ; }
gV() { cd ${HOME}/var/videos ; cls ; }
mV() { mv "$1" ${HOME}/var/videos ; }
YV() { cp "$1" ${HOME}/var/videos ; }
gm() { cd ${HOME}/var/music; cls ; }
mm() { mv "$1" ${HOME}/var/music ; cls ; }
Ym() { cp "$1" ${HOME}/var/music ; cls ; }
gB() { cd ${HOME}/var/books ; cls ; }
mB() { mv "$1" ${HOME}/var/books ; }
YB() { cp "$1" ${HOME}/var/books ; }
gr() { cd / ; cls ; }
mr() { doas mv "$1" / ; }
Yr() { doas cp "$1" / ; }
gvar() { cd /var ; cls ; }
mvar() { doas mv "$1" /var ; }
Yvar() { doas cp "$1" /var ; }
gu() { cd /usr ; cls ; }
mu() { doas mv "$1" /usr ; }
Yu() { doas cp "$1" /usr ; }
guL() { cd /usr/local ; cls ; }
muL() { doas mv "$1" /usr/local ; }
YuL() { doas cp "$1" /usr/local ; }
ge() { cd /etc ; cls ; }
me() { doas mv "$1" /etc ; }
Ye() { doas cp "$1" /etc ; }
gM() { cd /mnt ; cls ; }
mM() { doas mv "$1" /mnt ; }
YM() { doas cp "$1" /mnt ; }
gD() { cd /dev ; cls ; }
mD() { doas mv "$1" /dev ; }
YD() { doas cp "$1" /dev ; }
gl() { cd /lib ; cls ; }
ml() { doas mv "$1" /lib ; }
Yl() { doas cp "$1" /lib ; }
gO() { cd /opt ; cls ; }
mO() { doas mv "$1" /opt ; }
YO() { doas cp "$1" /opt ; }
gt() { cd ${HOME}/tmp ; cls ; }
mt() { mv "$1" ${HOME}/tmp ; }
Yt() { cp "$1" ${HOME}/tmp ; }
gcf() { cd ${HOME}/etc/config ; cls ; }
mcf() { mv "$1" ${HOME}/etc/config ; }
Ycf() { cp "$1" ${HOME}/etc/config ; }
gp() { cd ${HOME}/usr/programs ; cls ; }
mp() { mv "$1" ${HOME}/usr/programs ; }
Yp() { cp "$1" ${HOME}/usr/programs ; }
gs() { cd ${HOME}/etc/suckless ; cls ; }
ms() { mv "$1" ${HOME}/etc/suckless ; }
Ys() { cp "$1" ${HOME}/etc/suckless ; }

a dwmc='v ${HOME}/etc/suckless/dwm/dwm.c'
a surfc='v ${HOME}/etc/suckless/surf/surf.c'
a tabbedc='v ${HOME}/etc/suckless/tabbed/tabbed.c'
a dmenuc='v ${HOME}/etc/suckless/dmenu/dmenu.c'
a stc='v ${HOME}/etc/suckless/st/st.c'

a dwmcfg='v ${HOME}/etc/suckless/dwm/config.h'
a surfcfg='v ${HOME}/etc/suckless/surf/config.h'
a tabbedcfg='v ${HOME}/etc/suckless/tabbed/config.h'
a dmenucfg='v ${HOME}/etc/suckless/dmenu/config.h'
a stcfg='v ${HOME}/etc/suckless/st/config.h'

recomp() {
    stools="${HOME}/etc/suckless"
    progs=/"${HOME}/usr/programs"
    for i in "$@" ; do
        case $i in
            dwm)      doas ${HOME}/bin/recomp $stools/dwm ;; 
            surf)     doas ${HOME}/bin/recomp $stools/surf ;; 
            tabbed)   doas ${HOME}/bin/recomp $stools/tabbed ;; 
            st)       doas ${HOME}/bin/recomp $stools/st ;; 
            dmenu)    doas ${HOME}/bin/recomp $stools/dmenu ;; 
            slock)    doas ${HOME}/bin/recomp $stools/slock ;; 
            blind)    doas ${HOME}/bin/recomp $stools/blind ;; 
            quark)    doas ${HOME}/bin/recomp $stools/quark ;; 
            ii)       doas ${HOME}/bin/recomp $stools/ii ;; 
            sent)     doas ${HOME}/bin/recomp $stools/sent ;; 
            all)      recomp dwm surf tabbed st dmenu
        esac
    done
} ; a {repomc,recopm,recpom}=recomp
